#!/usr/bin/env python3

#-----------------------------------------------------#
#       _              _     _                        #
#      / \   _ __ ___ | |__ (_) ___ _ __   ___ ___    #
#     / _ \ | '_ ` _ \| '_ \| |/ _ \ '_ \ / __/ _ \   #
#    / ___ \| | | | | | |_) | |  __/ | | | (_|  __/   #
#   /_/   \_\_| |_| |_|_.__/|_|\___|_| |_|\___\___|   #
#                                                     #
#-----------------------------------------------------#

import argparse
import fcntl
import fnmatch
import os
import pygame
import random
import sys
import termios
import time
import tty

from pygame.locals import *
from pprint import pprint

class AmbientSounds():
    """AmbientSounds class"""

    version = "1.0.7"

    # FPS: Low number is used to reduce CPU;
    # Don't really need pygame's cycle running so frequently
    fps = 2

    # How long each sound should play (by itself)
    play_duration = 600

    # Number of ambient ticks (half seconds) for a fade
    fade_duration = 120
    fade_ms = fade_duration * 1000

    # Countdown timer for playing sound
    play_timer = 0

    # Storage of sound objects
    sounds = []
    current_sound = 0
    animate_chars = "◐◓◑◒"
    animate_position = 0

    # Path and sound files
    package_path = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(package_path, "sounds")
    files = []

    # Whether to listen to stdin in cli (experimental
    noinput = False

    def __init__(self, path=None, duration=5, noinput=False):
        if path:
            self.path = path

        # Calculate number of half seconds from minutes
        self.play_duration = float(duration) * (self.fps * 60);

        # If the duration is shorter than the standard fade, make a new fade duration
        if (self.play_duration <= self.fps * 60):
            self.fade_duration = float(self.play_duration / 5.0) # 5% of sound duration
            self.fade_ms = int(self.fade_duration * (1000.0 / self.fps))

        print("\n{}".format(AmbientSounds.get_version()))

        self.files = self.load_sound_files()

        self.noinput = bool(noinput)

    def get_version():
        return "Ambient version {}".format(AmbientSounds.version)

    def start(self):
        if len(self.files) == 0:
            print("No sound files to load!")
            pygame.quit()
            sys.exit(1)

        print("\nPlaying sounds. Press Ctrl-C to exit.")
        if not self.noinput:
            print("Press 'n' to go to next sound. Press 'q' to quit.")
        print("\033[?25l") # Hide cursor

        # Load the first sound
        self.load_sound(self.current_sound)

        # Start first sound
        self.sounds[self.current_sound].play(-1, fade_ms=3000)
        self.play_timer = int(self.play_duration - (self.fade_duration / 2) - (3 * self.fps))

    def tick(self):
        self.handle_play()
        self.print_current_sound()

    def print_current_sound(self):
        self.animate_position += 1
        if self.animate_position >= len(self.animate_chars):
            self.animate_position = 0
        animate_char = self.animate_chars[self.animate_position]
        sound_name = os.path.basename(self.files[self.current_sound])
        print("\r\033[K▶  Playing {} {} ".format(sound_name, animate_char), end="")

    def handle_play(self):
        if self.play_timer > 0:
            self.play_timer = self.play_timer - 1
            if self.play_timer == min(10, int(self.play_duration / 2)):
                # Load the next sound a few ticks before we need to play it
                self.load_sound(self.get_next_sound())
        else:
            self.stop_sound(self.current_sound)
            self.start_next_sound()

    def start_next_sound(self):
        self.current_sound = self.get_next_sound()

        self.play_sound(self.current_sound)

    def get_next_sound(self):
        next_sound = self.current_sound + 1

        if (next_sound >= len(self.files)):
            next_sound = 0

        return next_sound

    def next(self):
        self.load_sound(self.get_next_sound())
        self.stop_sound(self.current_sound, 2)
        self.current_sound = self.get_next_sound()
        self.play_sound(self.current_sound, 2)

    def play_sound(self, index, fade_override=None):
        fade_duration, fade_ms = self._get_fade_duration(fade_override)

        try:
            self.sounds[index].play(-1, fade_ms=fade_ms)
        except IndexError:
            self.load_sound(index)

        self.play_timer = int(self.play_duration - (fade_duration / 2))

    def stop_sound(self, index, fade_override=None):
        fade_duration, fade_ms = self._get_fade_duration(fade_override)

        self.sounds[index].fadeout(fade_ms)

    def end_fadeout(self, duration = 4000):
        print()
        print("Stopping sounds...")
        pygame.mixer.fadeout(duration)
        pygame.time.wait(duration)
        print("Goodbye.")

    def _get_fade_duration(self, fade_override=None):
        fade_duration = fade_override if fade_override else self.fade_duration
        fade_ms = int(fade_duration * (1000.0 / self.fps))
        return (fade_duration, fade_ms)

    def get_files(self, path):
        files = []

        try:
            for f in os.listdir(path):
                full = os.path.join(path, f)
                if os.path.isdir(full): files.extend(self.get_files(full)) # recurse
                if len(files) > 64: break # break if we have enough
                if fnmatch.fnmatch(f, '*.ogg'): files.append(full)
                #if fnmatch.fnmatch(f, '*.mp3'): files.append(full)
                if fnmatch.fnmatch(f, '*.wav'): files.append(full)
                if fnmatch.fnmatch(f, '*.flac'): files.append(full)
        except FileNotFoundError:
            print("Path '{}' not found".format(path))
            sys.exit(1)

        return files

    def load_sound_files(self):
        print("Reading sounds from path '{}'".format(self.path))
        files = self.get_files(self.path)
        random.shuffle(files)

        if len(files) == 0:
            return files

        print("Loaded sounds:")
        for index,file in enumerate(files):
            print("{}. {}".format(index + 1, file))
        return files

    def load_sound(self, file_index):
        try:
            sound = self.sounds[file_index]
        except IndexError:
            self.sounds.append(pygame.mixer.Sound(self.files[file_index]))

    def event_loop(self):
        while True:
            try:
                if self.noinput:
                    char = False
                else:
                    char = sys.stdin.read(1)
                self.handle_events(char)
            except KeyboardInterrupt:
                self.the_end()

    def handle_events(self, char_input=False):
        for event in pygame.event.get():
            if event.type == USEREVENT + 1:
                self.tick()
            if event.type == pygame.KEYUP:
                # Keyboard in pygame window (macos)
                self.handle_input(event.key)
        if char_input:
            # Stdin in cli
            self.handle_input(ord(char_input))

        pygame.time.Clock().tick(self.fps)

    def handle_input(self, key_code):
        print(chr(key_code), end="")
        if key_code == K_n:
            self.next()
        elif key_code == K_q:
            self.the_end()

    def the_end(self):
        self.end_fadeout()
        pygame.quit()
        print("\033[?25h") # Show cursor
        sys.exit(0)

class StdinReader():
    class raw(object):
        def __init__(self, stream):
            self.stream = stream
            self.fd = self.stream.fileno()
        def __enter__(self):
            self.original_stty = termios.tcgetattr(self.stream)
            tty.setcbreak(self.stream)
        def __exit__(self, type, value, traceback):
            termios.tcsetattr(self.stream, termios.TCSANOW, self.original_stty)

    class nonblocking(object):
        def __init__(self, stream):
            self.stream = stream
            self.fd = self.stream.fileno()
        def __enter__(self):
            self.orig_fl = fcntl.fcntl(self.fd, fcntl.F_GETFL)
            fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl | os.O_NONBLOCK)
        def __exit__(self, *args):
            fcntl.fcntl(self.fd, fcntl.F_SETFL, self.orig_fl)

def main():
    # Handle command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--version', action='store_true', help="show version and exit")
    parser.add_argument('-p', '--path', default=None, help="set the path where the sound files are")
    parser.add_argument('-d', '--duration', default=5, help="set the duration in minutes each sound will play: default=5")
    parser.add_argument('-n', '--noinput', action='store_true', help="disable the stdin input capture")
    (args, remaining_args) = parser.parse_known_args(sys.argv)

    # Display version and exit
    if args.version:
        print(AmbientSounds.get_version())
        sys.exit(0)

    # Determine path to sounds
    sounds_path = None
    if args.path:
        sounds_path = os.path.abspath(args.path)

    # Initialize pygame
    pygame.init()

    # Initialize AmbientSounds
    ambience = AmbientSounds(path=sounds_path, duration=args.duration, noinput=args.noinput)
    ambience.start()

    # This creates a timer event for the "tick" that will be passed to the
    # ambience class object. It is measured in milliseconds (1000 = 1 second)
    pygame.time.set_timer(USEREVENT + 1, int(1000 / ambience.fps))

    # Event loop
    if ambience.noinput:
        ambience.event_loop()
    else:
        with StdinReader.raw(sys.stdin):
            with StdinReader.nonblocking(sys.stdin):
                ambience.event_loop()

if __name__ == '__main__': main()
