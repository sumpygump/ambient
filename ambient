#!/usr/bin/env python3

#-----------------------------------------------------#
#       _              _     _                        #
#      / \   _ __ ___ | |__ (_) ___ _ __   ___ ___    #
#     / _ \ | '_ ` _ \| '_ \| |/ _ \ '_ \ / __/ _ \   #
#    / ___ \| | | | | | |_) | |  __/ | | | (_|  __/   #
#   /_/   \_\_| |_| |_|_.__/|_|\___|_| |_|\___\___|   #
#                                                     #
#-----------------------------------------------------#

import argparse
import fnmatch
import os
import pygame
import random
import sys

from pygame.locals import *
from pprint import pprint

class AmbientSounds():
    """AmbientSounds class"""

    version = "1.0.7"

    # FPS: Low number is used to reduce CPU;
    # Don't really need pygame's cycle running so frequently
    fps = 2

    # How long each sound should play (by itself)
    play_duration = 600

    # Number of ambient ticks (half seconds) for a fade
    fade_duration = 120
    fade_ms = fade_duration * 1000

    # Countdown timer for playing sound
    play_timer = 0

    # Storage of sound objects
    sounds = []
    current_sound = 0
    animate_chars = "◐◓◑◒"
    animate_position = 0

    # Path and sound files
    package_path = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(package_path, "sounds")
    files = []

    def __init__(self, path=None, duration=5):
        if path:
            self.path = path

        # Calculate number of half seconds from minutes
        self.play_duration = float(duration) * (self.fps * 60);

        # If the duration is shorter than the standard fade, make a new fade duration
        if (self.play_duration <= self.fps * 60):
            self.fade_duration = float(self.play_duration / 5.0) # 5% of sound duration
            self.fade_ms = int(self.fade_duration * (1000.0 / self.fps))

        print("\n{}".format(AmbientSounds.get_version()))
        print("duration: {}, fade: {}".format(self.play_duration, self.fade_duration))
        print("fade_ms: {}".format(self.fade_ms))

        self.files = self.load_sound_files()

    def get_version():
        return "Ambient version {}".format(AmbientSounds.version)

    def start(self):
        if len(self.files) == 0:
            print("No sound files to load!")
            pygame.quit()
            sys.exit(1)

        print("Playing sounds. Press Ctrl-C to exit.")
        print("\033[?25l") # Hide cursor

        # Load the first sound
        self.load_sound(self.current_sound)

        # Start first sound
        self.sounds[self.current_sound].play(-1, fade_ms=3000)
        self.play_timer = int(self.play_duration - (self.fade_duration / 2) - (3 * self.fps))

    def tick(self):
        self.handle_play()
        self.print_current_sound()

    def print_current_sound(self):
        self.animate_position += 1
        if self.animate_position >= len(self.animate_chars):
            self.animate_position = 0
        animate_char = self.animate_chars[self.animate_position]
        sound_name = os.path.basename(self.files[self.current_sound])
        print("\r\033[K▶  Playing {} {} ".format(sound_name, animate_char), end="")

    def handle_play(self):
        if self.play_timer > 0:
            self.play_timer = self.play_timer - 1
            if self.play_timer == min(10, int(self.play_duration / 2)):
                # Load the next sound a few ticks before we need to play it
                self.load_sound(self.get_next_sound())
        else:
            self.stop_sound(self.current_sound)
            self.start_next_sound()

    def start_next_sound(self):
        self.current_sound = self.get_next_sound()

        self.play_sound(self.current_sound)

    def get_next_sound(self):
        next_sound = self.current_sound + 1

        if (next_sound >= len(self.files)):
            next_sound = 0

        return next_sound

    def next(self):
        self.load_sound(self.get_next_sound())
        self.stop_sound(self.current_sound, 2)
        self.current_sound = self.get_next_sound()
        self.play_sound(self.current_sound, 2)

    def play_sound(self, index, fade_override=None):
        fade_duration, fade_ms = self._get_fade_duration(fade_override)

        try:
            self.sounds[index].play(-1, fade_ms=fade_ms)
        except IndexError:
            self.load_sound(index)

        self.play_timer = int(self.play_duration - (fade_duration / 2))

    def stop_sound(self, index, fade_override=None):
        fade_duration, fade_ms = self._get_fade_duration(fade_override)

        self.sounds[index].fadeout(fade_ms)

    def end_fadeout(self, duration = 4000):
        print()
        print("Stopping sounds...")
        pygame.mixer.fadeout(duration)
        pygame.time.wait(duration)
        print("Goodbye.")

    def _get_fade_duration(self, fade_override=None):
        fade_duration = fade_override if fade_override else self.fade_duration
        fade_ms = int(fade_duration * (1000.0 / self.fps))
        return (fade_duration, fade_ms)

    def get_files(self, path):
        files = []

        try:
            for f in os.listdir(path):
                full = os.path.join(path, f)
                if os.path.isdir(full): files.extend(self.get_files(full)) # recurse
                if len(files) > 64: break # break if we have enough
                if fnmatch.fnmatch(f, '*.ogg'): files.append(full)
                #if fnmatch.fnmatch(f, '*.mp3'): files.append(full)
                if fnmatch.fnmatch(f, '*.wav'): files.append(full)
                if fnmatch.fnmatch(f, '*.flac'): files.append(full)
        except FileNotFoundError:
            print("Path '{}' not found".format(path))
            sys.exit(1)

        return files

    def load_sound_files(self):
        print("Reading sounds from path '{}'".format(self.path))
        files = self.get_files(self.path)
        random.shuffle(files)

        if len(files) == 0:
            return files

        print("Loaded sounds:")
        for index,file in enumerate(files):
            print("{}. {}".format(index + 1, file))
        return files

    def load_sound(self, file_index):
        try:
            sound = self.sounds[file_index]
        except IndexError:
            self.sounds.append(pygame.mixer.Sound(self.files[file_index]))

def main():
    # Handle command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--version', action='store_true', help="show version and exit")
    parser.add_argument('-p', '--path', default=None, help="set the path where the sound files are")
    parser.add_argument('-d', '--duration', default=5, help="set the duration in minutes each sound will play: default=5")
    (args, remaining_args) = parser.parse_known_args(sys.argv)

    # Display version and exit
    if args.version:
        print(AmbientSounds.get_version())
        sys.exit(0)

    # Determine path to sounds
    sounds_path = None
    if args.path:
        sounds_path = os.path.abspath(args.path)

    # Initialize pygame
    pygame.init()

    # Initialize AmbientSounds
    ambience = AmbientSounds(path=sounds_path, duration=args.duration)
    ambience.start()

    # This creates a timer event for the "tick" that will be passed to the
    # ambience class object. It is measured in milliseconds (1000 = 1 second)
    pygame.time.set_timer(USEREVENT + 1, int(1000 / ambience.fps))

    def event_loop():
        for event in pygame.event.get():
            if event.type == USEREVENT + 1:
                ambience.tick()
            if event.type == pygame.KEYUP:
                # Keyboard input only works when pygame window has focus
                if event.key==K_n:
                    ambience.next()
                elif event.key==K_q:
                    the_end()

        pygame.time.Clock().tick(ambience.fps)

    def the_end():
        ambience.end_fadeout()
        pygame.quit()
        print("\033[?25h") # Show cursor
        sys.exit(0)

    # Event loop
    while True:
        try:
            event_loop()
        except KeyboardInterrupt:
            the_end()

if __name__ == '__main__': main()
